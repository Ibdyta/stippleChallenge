---
title: "Range Rover Blue Noise Stippling"
format:
  html: default
  pdf: default
execute:
  echo: false
  eval: true
---

```{r setup, include=FALSE}
# Setup chunk: Suppress the xfun::attr() deprecation warning
# This warning is harmless but can be annoying during rendering
# Individual code chunks can override these settings if needed
knitr::opts_chunk$set(
  warning = FALSE,  # Suppress warnings (including xfun deprecation)
  message = FALSE   # Suppress package loading messages
)
# Note: Chunks with explicit warning/message settings will override these defaults
```




```{r}
#| label: load-image-r
#| echo: false
#| fig-cap: "Original image before stippling"

library(imager)
library(ggplot2)

# Load the image
img_path <- 'ranges.png'
original_img <- load.image(img_path)

# Convert to grayscale if needed
# Check frames/channels (dim[4]): 3 for RGB color, 1 for grayscale
if(dim(original_img)[4] == 3) {
  original_img <- grayscale(original_img)
}

# Display the original image
plot(original_img, axes = FALSE, main = "Original Image")

cat("Image dimensions:", dim(original_img)[1], "x", dim(original_img)[2], "pixels\n")
```



```{r}
#| label: importance-map-r
#| echo: false
#| message: false
#| warning: false

compute_importance <- function(gray_img, 
                                extreme_downweight = 0.5,
                                extreme_threshold_low = 0.4,
                                extreme_threshold_high = 0.8,
                                extreme_sigma = 0.1,
                                mid_tone_boost = 0.4,
                                mid_tone_sigma = 0.2) {
  # Clip image to [0, 1]
  I <- pmax(pmin(gray_img, 1.0), 0.0)
  
  # Invert brightness
  I_inverted <- 1.0 - I
  
  # Dark mask
  dark_mask <- exp(-((I - 0.0)^2) / (2.0 * (extreme_sigma^2)))
  dark_mask[I >= extreme_threshold_low] <- 0.0
  if(max(dark_mask) > 0) {
    dark_mask <- dark_mask / max(dark_mask)
  }
  
  # Light mask
  light_mask <- exp(-((I - 1.0)^2) / (2.0 * (extreme_sigma^2)))
  light_mask[I <= extreme_threshold_high] <- 0.0
  if(max(light_mask) > 0) {
    light_mask <- light_mask / max(light_mask)
  }
  
  # Combine masks
  extreme_mask <- pmax(dark_mask, light_mask)
  
  # Apply downweighting
  importance <- I_inverted * (1.0 - extreme_downweight * extreme_mask)
  
  # Mid-tone boost
  mid_tone_center <- 0.65
  mid_tone_gaussian <- exp(-((I - mid_tone_center)^2) / (2.0 * (mid_tone_sigma^2)))
  if(max(mid_tone_gaussian) > 0) {
    mid_tone_gaussian <- mid_tone_gaussian / max(mid_tone_gaussian)
  }
  
  importance <- importance * (1.0 + mid_tone_boost * mid_tone_gaussian)
  
  # Normalize
  m <- min(importance)
  M <- max(importance)
  if(M > m) {
    importance <- (importance - m) / (M - m)
  }
  
  return(importance)
}
```



```{r}
#| label: stippling-functions-r
#| echo: false
#| message: false
#| warning: false

# Note: R implementation uses true 2D circular shift (roll2d) to match Python's np.roll behavior

toroidal_gaussian_kernel <- function(h, w, sigma) {
  y <- 0:(h-1)
  x <- 0:(w-1)
  
  # Compute toroidal distances
  dy <- pmin(y, h - y)
  dx <- pmin(x, w - x)
  
  # Create distance matrices
  # each row gets same dy, each col gets same dx
  dy_mat <- matrix(rep(dy, each = w), nrow = h, ncol = w)
  dx_mat <- matrix(rep(dx, times = h), nrow = h, ncol = w)
  
  # Compute Gaussian
  kern <- exp(-(dx_mat^2 + dy_mat^2) / (2.0 * sigma^2))
  kern <- kern / sum(kern)  # Normalize
  
  return(kern)
}

# Helper function for true 2D circular shift (equivalent to np.roll)
# np.roll equivalent: positive shift moves down/right
roll2d <- function(mat, shift_y = 0, shift_x = 0) {
  h <- nrow(mat)
  w <- ncol(mat)
  sy <- ((shift_y %% h) + h) %% h
  sx <- ((shift_x %% w) + w) %% w
  rows <- if (sy == 0) 1:h else c((h - sy + 1):h, 1:(h - sy))
  cols <- if (sx == 0) 1:w else c((w - sx + 1):w, 1:(w - sx))
  mat[rows, cols, drop = FALSE]
}

void_and_cluster <- function(input_img, 
                             percentage = 0.08,
                             sigma = 0.9,
                             content_bias = 0.9,
                             importance_img = NULL,
                             noise_scale_factor = 0.1) {
  # Clip image to [0, 1]
  I <- pmax(pmin(input_img, 1.0), 0.0)
  h <- nrow(I)
  w <- ncol(I)
  
  # Compute or use provided importance map
  if(is.null(importance_img)) {
    importance <- compute_importance(I)
  } else {
    importance <- pmax(pmin(importance_img, 1.0), 0.0)
  }
  
  # Create toroidal Gaussian kernel for repulsion
  kernel <- toroidal_gaussian_kernel(h, w, sigma)
  
  # Initialize energy field: lower energy â†’ more likely to be picked
  energy_current <- -importance * content_bias
  
  # Stipple buffer: start with white background; selected points become black dots
  final_stipple <- matrix(1.0, nrow = h, ncol = w)
  samples <- vector("list", as.integer(h * w * percentage))
  
  # Helper function to roll kernel to an arbitrary position
  # This implements the exact equivalent of Python's np.roll(kernel, shift=y, axis=0) 
  # followed by np.roll(kernel, shift=x, axis=1)
  # Uses true 2D circular shift to preserve directionality and avoid quadrant-mirroring
  energy_splat <- function(y, x) {
    # exact np.roll(kernel, y; x)
    roll2d(kernel, shift_y = y - 1, shift_x = x - 1)
  }
  
  # Number of points to select
  num_points <- as.integer(h * w * percentage)
  
  # Set seed for reproducibility
  set.seed(42)
  
  # --- first point: pick min in a center window ---
  cy <- as.integer(h / 2)
  cx <- as.integer(w / 2)
  r <- min(20L, as.integer(h / 10), as.integer(w / 10))
  y_start <- max(1L, cy - r)
  y_end <- min(h, cy + r)
  x_start <- max(1L, cx - r)
  x_end <- min(w, cx + r)
  
  region <- energy_current[y_start:y_end, x_start:x_end]
  flat_idx <- which.min(region)
  
  # IMPORTANT: R is column-major -> (y,x) from flat:
  # y = ((idx-1) %% nrow) + 1 ; x = ((idx-1) %/% nrow) + 1
  ry <- ((flat_idx - 1) %% nrow(region)) + 1
  rx <- ((flat_idx - 1) %/% nrow(region)) + 1
  y0 <- y_start + ry - 1
  x0 <- x_start + rx - 1
  
  # Place first point
  energy_current <- energy_current + energy_splat(y0, x0)
  energy_current[y0, x0] <- Inf  # Prevent reselection
  samples[[1]] <- c(y0, x0, I[y0, x0])
  final_stipple[y0, x0] <- 0.0  # Black dot
  
  # --- iterate ---
  for(i in 2:num_points) {
    # Add exploration noise that decreases over time
    exploration <- 1.0 - ((i - 1) / num_points) * 0.5  # Decrease from 1.0 to 0.5
    noise <- matrix(rnorm(h * w, 0, noise_scale_factor * content_bias * exploration), 
                    nrow = h, ncol = w)
    energy_with_noise <- energy_current + noise
    
    # Find position with minimum energy (with noise for exploration)
    pos_flat <- which.min(energy_with_noise)
    
    # Column-major unflatten:
    # R matrices are column-major, so y = (idx-1) %% h + 1, x = (idx-1) %/% h + 1
    y <- ((pos_flat - 1) %% h) + 1
    x <- ((pos_flat - 1) %/% h) + 1
    
    # Add Gaussian splat to prevent nearby points from being selected
    energy_current <- energy_current + energy_splat(y, x)
    energy_current[y, x] <- Inf  # Prevent reselection
    
    # Record the sample
    samples[[i]] <- c(y, x, I[y, x])
    final_stipple[y, x] <- 0.0  # Black dot
  }
  
  # Convert samples list to matrix
  samples_matrix <- do.call(rbind, samples[1:num_points])
  
  return(list(stipple = final_stipple, samples = samples_matrix))
}
```

:::

## Preparing the Working Image

Before generating the stippling pattern, we prepare the image by resizing if necessary and computing the importance map.



```{r}
#| label: prep-image-r
#| echo: false
#| message: false
#| warning: false

# Resize image if needed
max_size <- 512
img_dims <- dim(original_img)
if(img_dims[1] > max_size || img_dims[2] > max_size) {
  scale <- max_size / max(img_dims[1], img_dims[2])
  new_size <- c(round(img_dims[1] * scale), round(img_dims[2] * scale))
  img_resized <- resize(original_img, new_size[1], new_size[2])
  cat("Resized image to", new_size[1], "x", new_size[2], "for processing\n")
} else {
  img_resized <- original_img
}

# Convert to matrix and normalize
# imager uses (x,y,cc,z) = (width, height, channels, depth)
# but R matrices use (row, col) = (y, x)
# Extract grayscale plane and transpose to get [h, w] orientation
arr <- as.array(img_resized)          # dims: [x, y, cc, z] = [w, h, 1, 1]
img_matrix <- t(arr[,,1,1])           # now dims: [h, w]  (row=y, col=x)
img_matrix <- img_matrix / max(img_matrix)

# Apply contrast enhancement to darken the car body for better outlining
# Use a power curve to emphasize darker areas (car body will appear darker)
# Gamma correction: gamma < 1 darkens the image, making dark areas more prominent
gamma <- 0.65  # Lower gamma = darker image, better for car body outlining
img_matrix <- img_matrix^gamma

# Apply a contrast curve that further enhances dark-to-mid tones
# This curve boosts darker pixels more than lighter ones
contrast_curve <- function(x, power = 0.8) {
  # Power curve: lower values get boosted more
  x^power
}
img_matrix <- contrast_curve(img_matrix, power = 0.8)

# Renormalize to [0, 1] range
img_matrix <- (img_matrix - min(img_matrix)) / (max(img_matrix) - min(img_matrix) + 1e-10)

cat("Final image shape:", nrow(img_matrix), "x", ncol(img_matrix), "\n")
cat("Applied contrast enhancement (gamma=", gamma, ")\n", sep="")

# Compute importance map with adjusted parameters to emphasize darker areas (car body)
# Reduce downweighting of dark tones so car body gets more stipples
importance_map <- compute_importance(
  img_matrix,
  extreme_downweight = 0.3,        # Reduced from 0.5 to preserve more dark tones
  extreme_threshold_low = 0.3,     # Lower threshold to allow darker areas
  extreme_threshold_high = 0.85,   # Slightly higher to preserve light areas
  mid_tone_boost = 0.2             # Reduced mid-tone boost to focus on dark areas
)
cat("Importance map computed with enhanced dark tone preservation\n")
```

:::

## Generating the Stippled Image

Now let's apply the stippling algorithm to create the blue noise stippling pattern.


```{r}
#| label: generate-stipple-r
#| echo: false
#| message: false
#| warning: false

# Generate stippling pattern
cat("Generating blue noise stippling pattern...\n")
stipple_result <- void_and_cluster(
  img_matrix,
  percentage = 0.08,
  sigma = 0.9,
  content_bias = 0.9,
  importance_img = importance_map,
  noise_scale_factor = 0.1
)

stipple_pattern <- stipple_result$stipple
samples <- stipple_result$samples

cat("Generated", nrow(samples), "stipple points\n")
cat("Stipple pattern shape:", nrow(stipple_pattern), "x", ncol(stipple_pattern), "\n")
```

:::

## Displaying the Results

Let's visualize the original image, the importance map, and the stippled version side by side for comparison.


```{r}
#| label: display-results-r
#| echo: false
#| fig-cap: "Comparison of original image, importance map, and blue noise stippling"
#| fig-width: 7
#| fig-height: 4

par(mfrow = c(1, 3), mar = c(2, 2, 2, 2))

# Original
plot(img_resized, axes = FALSE, main = "Original Image")

# Importance map (matrix [h, w]) -> transpose for imager ([x, y])
plot(as.cimg(t(importance_map), x = ncol(importance_map), y = nrow(importance_map), cc = 1), 
     axes = FALSE, main = "Importance Map")

# Stipple pattern (matrix [h, w]) -> transpose for imager ([x, y])
plot(as.cimg(t(stipple_pattern), x = ncol(stipple_pattern), y = nrow(stipple_pattern), cc = 1), 
     axes = FALSE, main = "Blue Noise Stippling")
```

:::

## Progressive Stippling Animation


```{r}
#| label: progressive-stippling-r
#| echo: false
#| message: false
#| warning: false

# Use the existing samples from the already-computed stippling
cat("Using existing stippling with", nrow(samples), "points\n")
cat("Image shape:", nrow(img_matrix), "x", ncol(img_matrix), "\n")

# Create progressive frames by adding points sequentially
frame_increment <- 100
frames <- list()
point_counts <- c()

# Start with white background
progressive_stipple <- matrix(1.0, nrow = nrow(img_matrix), ncol = ncol(img_matrix))

# Add first point and save initial frame
if(nrow(samples) > 0) {
  y0 <- as.integer(samples[1, 1])
  x0 <- as.integer(samples[1, 2])
  progressive_stipple[y0, x0] <- 0.0
  frames[[1]] <- progressive_stipple
  point_counts <- c(point_counts, 1)
}

# Add remaining points sequentially and save frames at increments
for(i in 2:nrow(samples)) {
  y <- as.integer(samples[i, 1])
  x <- as.integer(samples[i, 2])
  progressive_stipple[y, x] <- 0.0  # Add black dot
  
  # Save frame at increments (100, 200, 300, ...) and at the end
  if(i %% frame_increment == 0 || i == nrow(samples)) {
    frames[[length(frames) + 1]] <- progressive_stipple
    point_counts <- c(point_counts, i)
  }
}

cat("Generated", length(frames), "frames\n")
cat("Point counts:", paste(point_counts, collapse = ", "), "\n")
```


Now let's create the GIF animation:


```{r}
#| label: create-gif-r
#| echo: false
#| include: false
#| message: false
#| warning: false

# Create GIF animation using magick package
library(magick)

cat("Creating GIF animation...\n")

# Create list of image frames
img_list <- lapply(1:length(frames), function(i) {
  frame <- frames[[i]]                 # matrix [h, w]
  # Convert matrix to image using imager - transpose for imager ([x, y])
  # Be explicit with dimensions to avoid shape misreads
  img <- as.cimg(t(frame), x = ncol(frame), y = nrow(frame), cc = 1)
  # Add title using magick (convert from imager first)
  img_magick <- image_read(as.raster(img))
  img_magick <- image_annotate(img_magick, 
                               paste("Progressive Stippling:", 
                                     point_counts[i], 
                                     "points"),
                               size = 20, color = "black", gravity = "north")
  return(img_magick)
})

# Combine frames into animated GIF
gif <- image_animate(image_join(img_list), fps = 2)
gif_path <- "progressive_stippling.gif"
image_write(gif, gif_path)

cat("GIF saved to:", gif_path, "\n")
cat("Total frames:", length(frames), "\n")
cat("Point counts:", paste(point_counts, collapse = ", "), "\n")
```

:::

![Progressive stippling animation showing the sequential build-up of points. Each frame represents an increment of 100 points, demonstrating how the blue noise stippling pattern develops as more points are added.](progressive_stippling.gif)